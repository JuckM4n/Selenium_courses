 #1. XPath запрос всегда начинается с символа / или //
#Когда мы начинаем запрос с символа /,  мы должны указать элемент, являющийся корнем нашего документа
"Корнем всегда будет элемент с тегом <html>. Пример: /html/body/header"
"Мы можем выполнить запрос //header, так как других заголовков у нас нет."

#2. Символ [ ] — это команда фильтрации
#Если по запросу найдено несколько элементов, то будет произведена фильтрация по правилу, указанному в скобках.
"По любому атрибуту, будь то id, class, title (или любой другой). Например, мы хотим найти картинку с летящим котом, для этого можно выполнить запрос //img[@id='bullet']"

"По порядковому номеру. Допустим, мы хотим выбрать вторую по порядку карточку с котом. Для этого найдем элемент с классом "row" и возьмем его второго потомка: //div[@class="row"]/div[2]"

"По полному совпадению текста - //p[text()="Lenin cat"] - это хорошая практика, особенно в случае мультиязычных сайтов."

"По частичному совпадению текста или атрибута. Для этого нужна функция contains. Запрос //p[contains(text(), "cat")] вернет нам все абзацы текста, которые содержат слово cat"
"Точно так же можно искать по частичному совпадению других атрибутов, это удобно, если у элемента несколько классов. Посмотрите на код навбара сайта с котами. Его можно найти селектором //div[contains(@class, "navbar")]"

"Допустим, мы хотим найти картинку обязательно с data-type "animal" и именем "bullet-cat", для этого подойдет запрос: //img[@name='bullet-cat' and @data-type='animal']"

#3. Символ * — команда выбора всех элементов
"Например можем найти текст в заголовке запросом //div/*[@class="jumbotron-heading"]. Это может быть удобно, когда мы не знаем точно тег элемента, который ищем."

#4. Поиск по классу в XPath регистрозависим
"Также как и в случае поиска по CSS-селектором будьте внимательными к регистру при поиске по классам:"
//div/*[@class="Jumbotron-heading"] не найдет элемент на нашей странице."

//button[text()="Gold"] - #как найти кнопку с точным текстом "Gold"